##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.vars.node_name }}-generate-certs
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app: {{ .Values.vars.node_name }}-generate-certs
    app.kubernetes.io/name: {{ .Values.vars.node_name }}-generate-certs
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    {{- include "labels.custom" . | nindent 2 }}
spec:
    backoffLimit: 6
    template:
      metadata:
        labels:
          app: {{ .Values.vars.node_name }}-generate-certs
          app.kubernetes.io/name: {{ .Values.vars.node_name }}-generate-certs
          app.kubernetes.io/instance: {{ .Release.Name }}
      spec:
        restartPolicy: "OnFailure"
        serviceAccountName: {{ $.Values.vault.serviceaccountname }}        
        securityContext:
          fsGroup: 1000
        initContainers:
        - name: init-check-certificates
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: IfNotPresent
          env:
            - name: VAULT_ADDR
              value: {{ $.Values.vault.address }}
            - name: VAULT_APP_ROLE
              value: {{.Values.vault.role}}
            - name: KUBERNETES_AUTH_PATH
              value: {{ $.Values.vault.authpath }}
            - name: CERTS_SECRET_PREFIX
              value: {{ $.Values.vault.certsecretprefix }}
            - name: MOUNT_PATH
              value: "/certcheck"
          command: ["sh", "-c"]
          args:
          - |-
              #!/usr/bin/env sh
              validateVaultResponse () {
                if echo ${2} | grep "errors"; then
                  echo "ERROR: unable to retrieve ${1}: ${2}"
                  exit 1
                fi
                if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
                then
                  http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                  --header "X-Vault-Token: ${VAULT_TOKEN}" \
                  ${VAULT_ADDR}/v1/${1})
                  curl_response=$?
                  if test "$http_code" != "200" ; then
                      echo "Http response code from Vault - $http_code and curl_response - $curl_response"
                      if test "$curl_response" != "0"; then
                        echo "Error: curl command failed with error code - $curl_response"
                        exit 1
                      fi
                  fi
                fi
              }
              # Setting up the environment to get secrets/certificates from Vault
              echo "Getting secrets/certificates from Vault server"
              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
              echo "Logged into Vault"
              mkdir -p ${MOUNT_PATH}
              echo ${VAULT_TOKEN}
              echo ${VAULT_ADDR}
              echo ${CERTS_SECRET_PREFIX}           
              LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/crypto/{{ .Values.vars.node_name }}/certs | jq -r 'if .errors then . else . end')
              echo ${LOOKUP_SECRET_RESPONSE}
              data_info="$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["rootCA"]')"
              echo ${data_info}
              if [ "$data_info" == "null" ]           
              then
                echo "Certficates absent in vault. Ignore error warning"
                touch ${MOUNT_PATH}/absent.txt
              else
                validateVaultResponse "${CERTS_SECRET_PREFIX}/certs" "${LOOKUP_SECRET_RESPONSE}" "LOOKUPSECRETRESPONSE"
                echo "Certificates present in vault"
                touch ${MOUNT_PATH}/present.txt
              fi 
              echo "Done checking for certificates in vault"
          volumeMounts:
          - name: credentials
            mountPath: /DATA
          - name: certcheck
            mountPath: /certcheck
        imagePullSecrets:
          - name: {{ $.Values.image.imagePullSecret }}
        containers:
        - name: certs-generation
          image: {{ .Values.image.certsContainerName }}
          env:
            - name: BASE_DIR
              value: "{{ .Values.volume.baseDir }}"
            - name: domain_name
              value: "{{ .Values.opensslVars.domain_name }}"
            - name: domain_name_api
              value: "{{ .Values.opensslVars.domain_name_api }}" 
            - name: domain_name_web
              value: "{{ .Values.opensslVars.domain_name_web }}"
            - name: domain_name_tessera
              value: "{{ .Values.opensslVars.domain_name_web }}" 
            - name: ambassadortls
              value: "{{ $.Values.subjects.ambassadortls }}"
            - name: rootca
              value: "{{ .Values.subjects.rootca }}"
            - name: node_name
              value: "{{ $.Values.vars.node_name }}"
            - name: CERTS_SECRET_PREFIX
              value: {{ $.Values.vault.certsecretprefix }}
            - name: VAULT_ADDR
              value: {{ $.Values.vault.address }}
            - name: VAULT_APP_ROLE
              value: {{.Values.vault.role}}
            - name: KUBERNETES_AUTH_PATH
              value: {{ $.Values.vault.authpath }}
            - name: CERTS_SECRET_PREFIX
              value: {{ $.Values.vault.certsecretprefix }}
            - name: root_subject
              value: "{{ .Values.vars.root_subject }}"
            - name: cert_subject
              value: "{{ .Values.vars.cert_subject }}"
            - name: ambassadortls_path
              value: "{{ $.Values.vars.ambassadortls }}"
            - name: rootca_path
              value: "{{ $.Values.vars.rootca }}"             
            - name: MOUNT_PATH
              value: "/certcheck"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          command: ["/bin/bash", "-c"]
          args:
          - |-
            if [ -e /certcheck/present.txt ]
            then
              echo "Certificates already present in the vault. Skipping.."
              exit 0
            fi            
            # create directories
            mkdir -p ${BASE_DIR}/DATA/rootca
            mkdir -p ${BASE_DIR}/DATA/ambassadortls
            cd ${BASE_DIR}/DATA/rootca
            set -x
            cat <<EOF >openssl.conf
            [req]
            req_extensions = v3_ca
            distinguished_name = dn
            [dn]
            [v3_ca]
            basicConstraints = critical, CA:TRUE
            keyUsage = critical,digitalSignature, keyCertSign, cRLSign
            extendedKeyUsage=serverAuth,clientAuth
            subjectKeyIdentifier = hash
            authorityKeyIdentifier = keyid:always

            [v3_nonca]
            basicConstraints = critical, CA:FALSE
            keyUsage = critical,digitalSignature, keyCertSign, cRLSign
            extendedKeyUsage=serverAuth,clientAuth
            subjectKeyIdentifier = hash
            authorityKeyIdentifier = keyid:always
            EOF
            keytool -genkey -alias rootca -dname "${root_subject}" -keystore rootca.jks -storepass quorum -keypass quorum
            openssl ecparam -name prime256v1 -genkey -noout -out rootca.key
            openssl req -x509 -config openssl.conf -new -nodes -key rootca.key -days 1024 -out rootca.pem -extensions v3_ca -subj "/${root_subject}"
            openssl pkcs12 -export -name cert -inkey rootca.key -in rootca.pem -out rootcacert.pkcs12 -cacerts -passin pass:'quorum' -passout pass:'quorum'
            openssl pkcs12 -export -name key -inkey rootca.key -in rootca.pem -out rootcakey.pkcs12 -passin pass:'quorum' -passout pass:'quorum'
            keytool -importkeystore -srckeystore rootcacert.pkcs12 -srcstoretype PKCS12 -srcstorepass quorum -destkeystore rootca.jks -deststorepass quorum
            keytool -importkeystore -srckeystore rootcakey.pkcs12 -srcstoretype PKCS12 -srcstorepass quorum -destkeystore rootca.jks -deststorepass quorum
            pwd
            cd ${BASE_DIR}/DATA/ambassadortls
            cat <<EOF >openssl${node_name}.conf
            [dn]
            CN=cmani.rc.dev2.aws.blockchaincloudpoc-develop.com
            [req]
            distinguished_name = dn
            [EXT]
            keyUsage=digitalSignature
            extendedKeyUsage=serverAuth
            subjectAltName = @alt_names
            [v3_nonca]
            basicConstraints = critical, CA:FALSE
            keyUsage = critical,digitalSignature, keyCertSign, cRLSign
            extendedKeyUsage=serverAuth,clientAuth
            subjectKeyIdentifier = hash
            authorityKeyIdentifier = keyid:always

            [alt_names]
            DNS.1 = cmani.rc.dev2.aws.blockchaincloudpoc-develop.com
            DNS.2 = cmaniapi.rc.dev2.aws.blockchaincloudpoc-develop.com
            DNS.3 = cmaniweb.rc.dev2.aws.blockchaincloudpoc-develop.com
            DNS.4 = cmani-tessera.cmani
            EOF
            cat openssl${node_name}.conf
            cd ${BASE_DIR}/DATA/ambassadortls
            openssl ecparam -name prime256v1 -genkey -noout -out ${node_name}.key
            openssl req -new -nodes -key ${node_name}.key -days 1000 -out ${node_name}.csr -extensions EXT -subj "/CN=${domain_name}" -config openssl${node_name}.conf
            openssl x509 -extfile openssl${node_name}.conf -req -days 1000 -in ${node_name}.csr -CA ${rootca_path}/rootca.pem -CAkey ${rootca_path}/rootca.key -out ${node_name}.pem -set_serial 01 -extensions v3_nonca
            cat ${node_name}.pem > ${node_name}-certchain.pem
            cat ${rootca_path}/rootca.pem >> ${node_name}-certchain.pem
            #creating a dummy file to perform check if last line is executed or not.
            touch ${BASE_DIR}/DATA/done.txt
          volumeMounts:
          - name: certcheck
            mountPath: /certcheck
        imagePullSecrets:
          - name: {{ $.Values.image.imagePullSecret }}
        volumes:
          - name: certcheck
            emptyDir:
              medium: Memory
          - name: credentials
            emptyDir:
              medium: Memory
          - name: certs-keys
            emptyDir:
              medium: Memory
          - name: certs-etc
            emptyDir:
              medium: Memory
          - name: openssl-config
            configMap:
              name: {{ .Values.vars.node_name }}-conf

