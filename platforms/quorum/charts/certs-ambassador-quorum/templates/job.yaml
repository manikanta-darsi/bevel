##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.nodeName }}-generate-certs
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app: {{ .Values.nodeName }}-generate-certs
    app.kubernetes.io/name: {{ .Values.nodeName }}-generate-certs
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    {{- include "labels.custom" . | nindent 2 }}
spec:
    backoffLimit: 6
    template:
      metadata:
        labels:
          app: {{ .Values.nodeName }}-generate-certs
          app.kubernetes.io/name: {{ .Values.nodeName }}-generate-certs
          app.kubernetes.io/instance: {{ .Release.Name }}
      spec:
        restartPolicy: "OnFailure"
        serviceAccountName: {{ $.Values.vault.serviceAccountName }}        
        securityContext:
          fsGroup: 1000
        initContainers:
        - name: init-check-certificates
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: IfNotPresent
          env:
            - name: VAULT_ADDR
              value: {{ $.Values.vault.address }}
            - name: NODE_NAME
              value: {{.Values.vault.NODE_NAME}}
            - name: VAULT_APP_ROLE
              value: {{.Values.vault.role}}
            - name: KUBERNETES_AUTH_PATH
              value: {{ $.Values.vault.authPath }}
            - name: CERTS_SECRET_PREFIX
              value: {{ .Values.vault.certSecretPrefix }}
            - name: MOUNT_PATH
              value: "/certcheck"
          command: ["sh", "-c"]
          args:
          - |-
              #!/usr/bin/env sh
              validateVaultResponse () {
                if echo ${2} | grep "errors"; then
                  echo "ERROR: unable to retrieve ${1}: ${2}"
                  exit 1
                fi
                if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
                then
                  http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                  --header "X-Vault-Token: ${VAULT_TOKEN}" \
                  ${VAULT_ADDR}/v1/${1})
                  curl_response=$?
                  if test "$http_code" != "200" ; then
                      echo "Http response code from Vault - $http_code and curl_response - $curl_response"
                      if test "$curl_response" != "0"; then
                        echo "Error: curl command failed with error code - $curl_response"
                        exit 1
                      fi
                  fi
                fi
              }
              # Setting up the environment to get secrets/certificates from Vault
              echo "Getting secrets/certificates from Vault server"
              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
              echo "Logged into Vault"
              mkdir -p ${MOUNT_PATH}
              LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/${NODE_NAME}/certs | jq -r 'if .errors then . else . end')
              data_info="$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data["rootCA"]')"
              
              if [ "$data_info" == "null" ]           
              then
                echo "Certficates absent in vault. Ignore error warning"
                touch ${MOUNT_PATH}/absent.txt
              else
                validateVaultResponse "${CERTS_SECRET_PREFIX}/certs" "${LOOKUP_SECRET_RESPONSE}" "LOOKUPSECRETRESPONSE"
                echo "Certificates present in vault"
                touch ${MOUNT_PATH}/present.txt
              fi 
              echo "Done checking for certificates in vault"
          volumeMounts:
          - name: certcheck
            mountPath: /certcheck
        - name: init-credentials
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: IfNotPresent
          env:
            - name: VAULT_ADDR
              value: {{ $.Values.vault.address }}
            - name: KUBERNETES_AUTH_PATH
              value: {{ $.Values.vault.authPath }}
            - name: VAULT_APP_ROLE
              value: {{ $.Values.vault.role }}
            - name: BASE_DIR
              value: {{ $.Values.volume.baseDir }}
            - name: CERTS_SECRET_PREFIX
              value: {{ .Values.vault.certSecretPrefix }}
            - name: MOUNT_PATH
              value: "/DATA"
            - name: NODEINFO_MOUNT_PATH
              value: "/notary-nodeinfo"
          command: ["sh", "-c"]
          args:
          - |-
              #!/usr/bin/env sh
              validateVaultResponse () {
                if echo ${2} | grep "errors"; then
                  echo "ERROR: unable to retrieve ${1}: ${2}"
                  exit 1
                fi
                if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
                then
                  http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                  --header "X-Vault-Token: ${VAULT_TOKEN}" \
                  ${VAULT_ADDR}/v1/${1})
                  curl_response=$?
                  if test "$http_code" != "200" ; then
                      echo "Http response code from Vault - $http_code and curl_response - $curl_response"
                      if test "$curl_response" != "0"; then
                        echo "Error: curl command failed with error code - $curl_response"
                        exit 1
                      fi
                  fi
                fi
              }
              if [ -e /certcheck/present.txt ]
              then
                echo "Certificates already present in the vault. Skipping.."
                exit 0
              fi
              # Setting up the environment to get secrets from Vault
              echo "Getting secrets from Vault Server"
              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"vault-role","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
              echo "logged into vault"
              # Creating dirs for storing certificates
              mkdir -p ${MOUNT_PATH}/keystore;

              OUTPUT_PATH=${MOUNT_PATH}/keystore;
              # Fetching credentials for keystores
              LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/credentials/keystore | jq -r 'if .errors then . else . end')
              validateVaultResponse "${CERTS_SECRET_PREFIX}/credentials/keystore" "${LOOKUP_SECRET_RESPONSE}" "LOOKUPSECRETRESPONSE"
              KEYSTORE_PASS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data["keystorepass"]')
              echo "${KEYSTORE_PASS}"> ${OUTPUT_PATH}/keystorepass
              
              touch /DATA/done.txt
              echo "Done"
          volumeMounts:
          - name: credentials
            mountPath: /DATA
          - name: certcheck
            mountPath: /certcheck
        containers:
        - name: certs
          image: "{{ required "certs[main]: missing value for .Values.image.certsContainerName" .Values.image.certsContainerName }}"
          env:
            - name: BASE_DIR
              value: "{{ .Values.volume.baseDir }}"
            - name: NODE_NAME
              value: "{{ .Values.vars.NODE_NAME }}"
            - name: domain_name
              value: "{{ .Values.opensslVars.domain_name }}"
            - name: domain_name_api
              value: "{{ .Values.opensslVars.domain_name_api }}" 
            - name: domain_name_web
              value: "{{ .Values.opensslVars.domain_name_web }}"
            - name: domain_name_tessera
              value: "{{ .Values.opensslVars.domain_name_web }}" 
            - name: ambassadortls
              value: "{{ .Values.subjects.ambassadortls }}"
            - name: rootca
              value: "{{ .Values.subjects.rootca }}"

                           
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          command: ["/bin/bash", "-c"]
          args:
          - |-
            if [ -e /certcheck/present.txt ]
            then
              echo "Certificates already present in the vault. Skipping.."
              exit 0
            fi
            rm -r ${BASE_DIR}/DATA/done.txt
            
            # create directories
            mkdir -p ${BASE_DIR}/DATA/rootca
            mkdir -p ${BASE_DIR}/DATA/ambassadortls
            KEYSTORE_PASS=$(cat ${BASE_DIR}/credentials/keystore/keystorepass)

            cd ${BASE_DIR}/DATA/ambassadortls
            cat <<EOF >openssl ${NODE_NAME}.conf
            [dn]
            CN=${domain_name}
            [req]
            distinguished_name = dn
            [EXT]
            keyUsage=digitalSignature
            extendedKeyUsage=serverAuth
            subjectAltName = @alt_names

            [alt_names]
            DNS.1 = ${domain_name}
            DNS.2 = ${domain_name_api}
            DNS.3 = ${domain_name_web}
            DNS.4 = ${domain_name_tessera}
            EOF
       
            cd ${BASE_DIR}/DATA/rootca
            set -x
            keytool -genkey -keyalg RSA -alias key -dname "{{ .Values.subjects.rootca }}" -keystore keys.jks -storepass $KEYSTORE_PASS -keypass $KEYSTORE_PASS
            openssl ecparam -name prime256v1 -genkey -noout -out quorumrootca.key
            openssl req -x509 -config ${BASE_DIR}/openssl.conf -new -nodes -key quorumrootca.key -days 1024 -out quorumrootca.pem -extensions v3_ca -subj '/{{ .Values.subjects.rootca | replace "," "/" }}'
            openssl pkcs12 -export -name cert -inkey quorumrootca.key -in quorumrootca.pem -out quorumrootcacert.pkcs12 -cacerts -passin pass:${KEYSTORE_PASS} -passout pass:${KEYSTORE_PASS}
            openssl pkcs12 -export -name key -inkey quorumrootca.key -in quorumrootca.pem -out quorumrootcakey.pkcs12 -passin pass:${KEYSTORE_PASS} -passout pass:${KEYSTORE_PASS}
            eval "yes | keytool -importkeystore -srckeystore quorumrootcacert.pkcs12 -srcstoretype PKCS12 -srcstorepass $KEYSTORE_PASS -destkeystore keys.jks -deststorepass $KEYSTORE_PASS"
            eval "yes | keytool -importkeystore -srckeystore quorumrootcakey.pkcs12 -srcstoretype PKCS12 -srcstorepass $KEYSTORE_PASS -destkeystore keys.jks -deststorepass $KEYSTORE_PASS"

            cd ${BASE_DIR}/DATA/ambassadortls
            openssl ecparam -name prime256v1 -genkey -noout -out ${NODE_NAME}.key
            openssl req -new -nodes -key ${NODE_NAME}.key -days 1000 -out ${NODE_NAME}.csr \
            -extensions EXT -subj "/CN=${domain_name}" -config "{{ .Values.subjects.ambassadortls }}/openssl${NODE_NAME}.conf"
            openssl x509 -extfile ${BASE_DIR}/openssl.conf -req -days 1000 -in ${NODE_NAME}.csr -CA{{ .Values.subjects.rootca }}/rootca.pem -CAkey ${rootca}/rootca.key -out ${NODE_NAME}.pem -set_serial 01 -extensions v3_nonca
            cat ${NODE_NAME}.pem > ${NODE_NAME}-certchain.pem
            cat ${rootca}/rootca.pem >> ${NODE_NAME}-certchain.pem
            #creating a dummy file to perform check if last line is executed or not.
            touch ${BASE_DIR}/DATA/done.txt
            KUBECONFIG= kubectl create secret tls ${NODE_NAME} -ambassador-certs --cert=${ambassadortls}/${NODE_NAME}-certchain.pem --key=${ambassadortls}/${NODE_NAME}.key -n ${CERTS_SECRET_PREFIX}
          volumeMounts:
          - name: certcheck
            mountPath: /certcheck
          - name: credentials
            mountPath: {{ .Values.volume.baseDir }}/credentials
          - name: certs-keys
            mountPath: {{ .Values.volume.baseDir }}/DATA
          - name: certs-etc
            mountPath: {{ .Values.volume.baseDir }}/etc
          - name: openssl-config
            mountPath: {{ .Values.volume.baseDir }}/openssl.conf
            subPath: openssl.conf
        - name: store-certs
          image: {{ .Values.image.initContainerName }}
          imagePullPolicy: IfNotPresent
          env:
             - name: VAULT_ADDR
               value: {{ $.Values.vault.address }}
             - name: KUBERNETES_AUTH_PATH
               value: {{ $.Values.vault.authPath }}
             - name: VAULT_APP_ROLE
               value: {{ $.Values.vault.role }}
             - name: BASE_DIR
               value: {{ $.Values.volume.baseDir }}
             - name: CERTS_SECRET_PREFIX
               value: {{ .Values.vault.certSecretPrefix }}
          command: ["sh", "-c"]
          args:
          - |-
            #!/usr/bin/env sh
            validateVaultResponse () {
              if echo ${2} | grep "errors"; then
                 echo "ERROR: unable to retrieve ${1}: ${2}"
                 exit 1
              fi
            }
            
            if [ -e /certcheck/present.txt ]
            then
              echo "Certificates already present in the vault. Skipping.."
              exit 0
            fi
            # setting up env to get secrets from vault
            KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
            VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
            validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
            cd ${BASE_DIR}/DATA
            # putting certificates
            COUNTER=1
            while [ "$COUNTER" -lt {{ $.Values.vault.retries }} ]
            do
              if [ -e done.txt ]
              then
                cd ${BASE_DIR}/DATA
                echo "found certificates, performing vault put"
                # Use -w0 to get single line base64 -w0
                ROOT_CA=$(cat ./rootca/keys.jks | base64 -w0)
                CA_CERTS=$(cat ./rootca/rootca.pem | base64 -w0)
                KEYSTORE=$(cat ./rootca/rootca.key | base64 -w0)
                AMBASSODOR_CERTS=$(cat ./ambassadortls/${NODE_NAME}-certchain.pem | base64-w0)
                AMBASSODOR_CERTS=$(cat ./ambassadortls/${NODE_NAME}.key | base64 -w0)
                ROOTCACERTPKCS_12=$(cat ./rootca/rootcacert.pkcs12 | base64 -w0)
                ROOTCAKEYSPKCS_12=$(cat ./rootca/rootkeys.pkcs12 | base64 -w0)

                echo "{\"data\": {
                    \"{{ .Values.nodeName }}.jks\",
                    \"rootcakey\": \"${ROOT_CA}\",
                    \"cacerts\": \"${CA_CERTS}\",
                    \"keystore\": \"${KEYSTORE}\",
                    \"ambassadortls{{ .Values.nodeName }}-certchain.pem\": \"${AMBASSODOR_CERTS}\",
                    \"ambassadortls{{ .Values.nodeName }}.key": \"${AMBASSODOR_KEYS}\"
                    \"rootcacerts\": \"${ROOTCACERTPKCS_12}\",
                    \"rootcakeys\": \"${ROOTCAKEYSPKCS_12}\"
                  }}" > payload.json
                   
                echo "before curl"
                curl \
                 --header "X-Vault-Token: ${VAULT_TOKEN}" \
                 --request POST \
                 --data @payload.json \
                ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/certs
                
                echo "after POST"
              
                # get certs from vault

                LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_TOKEN}" ${VAULT_ADDR}/v1/${CERTS_SECRET_PREFIX}/certs | jq -r 'if .errors then . else . end')
                NODE_KEYS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "{{ .Values.nodeName }}.jks" ]' 2>&1)
                QUORUM_SSL_ROOT_KEYS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "rootcakey" ]' 2>&1)
                QUORUM_CA_CERTS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "cacerts" ]' 2>&1)
                ROOT_KEYSTORE=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "keystore" ]' 2>&1)
                AMBASSODOR_CERTS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "{{ .Values.nodeName }}-certchain.pem "]' 2>&1)
                AMBASSODOR_KEYS=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "{{ .Values.nodeName }}.pem" ]' 2>&1)
                ROOTCACERTPKCS_12=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "rootcacerts" ]' 2>&1)
                ROOTCACAKEYPKCS_12=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data[ "rootkeys" ]' 2>&1)
                
                if [ "$NODE_KEYS" == "null" ] || [ "$QUORUM_SSL_ROOT_KEYS" == "null" ] || [ "$QUORUM_CA_CERTS" == "null" ] || [ "$ROOT_KEYSTORE" == "null" ] || [ "$AMBASSODOR_CERTS" == "null" ] || [ "$AMBASSODOR_KEYS" == "null" ] || [ "$ROOTCACERTPKS_12" == "null" ] || [ "$ROOTCACAKEYPKCS_12" == "null" ] || [[ "$NODE_KEYS" == "parse error"* ]] || [[ "$QUORUM_SSL_ROOT_KEYS" == "parse error"* ]] || [[ "$quorum_CA_CERTS" == "parse error"* ]] || [[ "$ROOT_KEYSTORE" == "parse error"* ]] || [[ "$AMBASSODOR_CERTS" == "parse error"* ]] || [[ "$AMBASSODOR_KEYS" == "parse error"* ]] ||[ "$ROOTCACERTPKS_12" == "parse error"* ] || [ "$ROOTCACAKEYPKCS_12" == "parse error"* ]]
                then
                  echo "certificates write or read fail"
                  sleep {{ $.Values.vault.sleepTimeAfterError  }}
                  if [ "$COUNTER" -ge {{ $.Values.vault.retries }} ]
                  then
                    echo "Retry attempted $COUNTER times, certificates have not been saved"
                    exit 1
                  fi
                fi
                break
                COUNTER=`expr "$COUNTER" + 1`
              fi
            done
            if [ "$COUNTER" -gt {{ $.Values.vault.retries }} ]
            then
              echo "Retry attempted $COUNTER times, no files found. Giving up!"
              exit 1
              break
            fi
            echo "completed"
          volumeMounts:
          - name: certcheck
            mountPath: /certcheck
          - name: certs-keys
            mountPath: {{ .Values.volume.baseDir }}/DATA
            readOnly: false
        imagePullSecrets:
          - name: {{ .Values.image.imagePullSecret }}
        volumes:
          - name: certcheck
            emptyDir:
              medium: Memory
          - name: credentials
            emptyDir:
              medium: Memory
          - name: certs-keys
            emptyDir:
              medium: Memory
          - name: certs-etc
            emptyDir:
              medium: Memory
          - name: openssl-config
            configMap:
              name: {{ .Values.nodeName }}-config
